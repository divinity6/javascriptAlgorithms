## Divide and Conquer
### 분할 정복 패턴

- 이 패턴은 실제 사용되는 문서화된 패턴이다


- 정렬 중 퀵 정렬과 병합 정렬은 분할 정복 알고리즘의 예시들이다


- 탐색 중 이진 탐색도 분할 정복 알고리즘의 예시이며, 이진 탐색 트리도 분할 정복을 살펴봐야 한다


- 이진 탐색 자체는 고급 기능이라 이진 탐색 전체를 다루지는 않는다

---

### 개념

- 이 알고리즘은 주로 배열, 문자열 같은 큰 규모의 데이터 셋을 처리한다
  - ( 링크드 리스트, 트리등이 될 수도 있다 )


- 예시 )
  - 배열을 하나 만들어 보겠다.
  - 해당 배열에서 값을 찾기 위해, 배열의 왼쪽에서 오른쪽 끝까지 이동하는 것보다
  - 배열을 작은 조각으로 세분화하여 
  - 각 조각들을 어디로 이동시킬지 결정하는 작업부터 진행한다


- 즉, **큰 데이터 덩어리를 작은 조각으로 나누는 것**이다


- 문제에 따라 큰 도움이 될 수도 있지만, 항상 그렇지는 않다

- 탐색 알고리즘의 이진 탐색, or 일반 탐색 알고리즘이 그 예이다
---

### An Example

#### 배열은 정렬된 상태여야 한다. 그리고 배열은 2번째 파라미터의 값이 있는 index 를 반환한다

````javascript
    
    search( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 4 ) // 3
    
    search( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 6 ) // 5
    
    search( [ 1 , 2 , 3 , 4 , 5 , 6 ] , 11 ) // -1

````

---

### A native solution

````javascript
    
    function search( arr , val ){
        
        for ( let i = 0; i < arr.length; i++ ){
            if ( val === arr[ i ] ){
                return i;
            }
        }
        return -1;
    
    }

````

- 순진한 해결법으로 접근하면, 처음부터 일일히 살펴봐야하기 때문에


- 시간복잡도는 반드시 **O(n)** 이 된다


- 정렬된 배열을 한번 훑어보고 찾거나 못찾거나이다

---

### Refactor

- 이진 탐색은 약간 다른 것을 지닌다

````javascript
    
    function search( arr , val ){
        
        let min = 0;
        let max = arr.length - 1;
        
        while( min <= max ){
            
            /**
             * - 중간 index 를 구한다 
             * 
             * --> 아, 중간 index 를 구해서 , 그값보다 큰지 작은지
             *     계속 판단하는 거구나
             */
            let middle = Math.floor( ( min + max ) / 2 );
            
            let currentElement = arr[ middle ];
            
            if ( arr[ middle ] < val ){
                min = middle + 1;
            }
            else if ( arr[ middle ] > val ){
                max = middle - 1;
            }
            else {
                return middle;
            }
        }
        
        return -1;
    
    }

````

- 전체에서 반씩 계속 잘라가며 확인하는 알고리즘이다


- 일일히 확인하는 것 보다 중간 중간 잘라서 체크하는 것의 step 이 훨씬 적다


- 즉, 시간복잡도는 **O(log n)** 이다


- 정리 : 큰 데이터 셋에서, 작은 하위 데이터 셋으로 분할하고, 
- 나머지 부분은 무시하는 분할 정보 개념이다

---

- **분할과 정복**은 정말 보편적으로 자주 쓰이는 패턴이다