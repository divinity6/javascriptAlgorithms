/**
 * 프로그람 설명문서 주석
 * 2022.11.24
 *
 *
 *           ===== Big O Notation =====
 *
 *    - 지금까지의 알고리즘은 시간과 관계되어 있었다
 *      ( 얼마나 빠르게 실행되는지... )
 *
 *    --> 시간 복잡도
 *
 *    ----> 입력이 커질수록 알고리즘의 실행속도가 어떻게 바뀌는지 보는 것
 *
 *    --> 공간 복잡도
 *
 *    ----> 입력이 커질수록 알고리즘이 얼마나 많은 공간을 차지하는지 보는 것
 *
 *    ----> 빅오 표기법을 사용할 수 있는데 사용되는 메모리에 주목하는 것이다
 *
 *    - 보조 공간 복잡도
 *
 *    --> 입력되는 것을 제외하고 알고리즘 자체가 필요로하는 공간
 *
 *    - BIG O 에서는 n 이 커지는 것을 보려고 하는 것이기 때문에,
 *      n 이 커질수록 입력이 커진다는 것을 가정한다
 *
 *    --> 입력이 차지하는 공간은 관심없다
 *        ( 알고리즘 자체가 어떤 영향을 주는지 봐야한다 )
 *
 *    ----> 보조 공간 복잡도 === 공간 복잡도
 *
 *    ========================================================
 *                          기본적인 룰
 *    ========================================================
 *
 *    1. boolean , number , undefined , null
 *    --> 전부 불변의 공간이다
 *    --> 따라서 입력의 크기와는 상관없이 숫자가 1이든 1000 이든 모두 불변 공간이다
 *
 *    2. String 은 O(n)의 공간이 필요하다
 *
 *    --> n 이 문자열의 길이라면 50자인 입력이 있다면,
 *        해당 문자열은 길이가 1인 문자열보다 50배 더 많은 공간을 차지하게 될것이다
 *
 *    3. reference 타입, array , object 도 O(n)의 공간이 필요하다
 *
 *    --> n 은 배열의 길이이거나 객체의 키 갯수일 수 있다
 *
 *    --> 만약 배열의 길이가 4이고, 다른 배열의 길이가 2 라면,
 *        길이가 긴 배열이 짧은 배열보다 2배 더 많은 공간을 차지한다
 *
 *
 * */
title( '공간복잡도 예시' );
{

    /**
     * - 공간복잡도
     *
     * --> 공간을 차지하는 것
     *
     * 1. total
     *
     * 2. i = 0
     *
     * 이게 끝이다.
     *
     * - n 이 아무리 커지도라도 차지하는 공간은 i , total 두개의 변수밖에 없다
     *
     * 즉!! O(1)의 공간 복잡도를 가진다
     *
     */
    function sum( arr ){
        let total = 0;
        for ( let i = 0; i < arr.length; i++ ){
            total += arr[ i ];
        }
        return total;
    }

    /**
     * - 다른 예시
     *
     * 새로운 Array 에 2 를 곱해서 반환한다
     *
     * - 그렇다면 배열의 크기가 늘어날 수록 공간 복잡도는 어떻게 될까?
     *
     * newArr
     * - 새로 만든 빈배열은 입력과 비례해서 길어진다
     *
     * - 입력된 길이가 10이면 새로운 배열에 저장되는 아이템이 열개가 된다
     *
     * --> 따라서 ,차지하는 공간은 입력된 배열의 크기와 비례하여 커지게 된다
     *
     * 즉!! O(n)의 공간 복잡도를 가진다
     */
    function double( arr ){
        let newArr = [];
        for ( let i = 0; i < arr.length; i++ ){
            newArr.push( 2 * arr[ i ] );
        }
        return newArr;
    }
}