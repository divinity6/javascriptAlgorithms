## MULTIPLE POINTERS
### 다중 포인터 패턴

- 이 패턴의 개념은 인덱스나 위치에 해당하는 포인터나 값을 특정 조건에 따라
- 중간 지점부터 시작 지점이나 끝 지점 , 양쪽 지점을 향해 이동시키는 것이다


- array , string 같은 선형 구조나 이중 연결 리스트나 단일 연결 리스트를 만드는 것이다


- 한쌍의 값이나 조건을 충족시키는 무언가를 찾는것이다

---

### AN EXAMPLE

#### 정렬된 배열을 받는 sumZero 라는함수를 작성한다
#### 분류( assorted )가 아니라 정렬( assorted )된 배열이어야 한다.
#### 다만 오름차순이어야 한다
#### 이 함수는 합계가 0인 첫 번째 쌍, 즉, 한숫자를 다른 숫자에 더하면 0이되는 쌍을 찾는다


````javascript
    
    /** -3 과 3 을 더하면 0 이 되므로 [ -3 , 3 ] 을 반환한다 */
    sumZero( [ -3 , -2 , -1 , 0 , 1 , 2 , 3 ] ) // [ -3 , 3 ]
    /** 합이 0 인 쌍이 없기 때문에 undefined 를 반환한다  */
    sumZero( [ -2 , 0 , 1 , 3 ] ) // undefined
    sumZero( [ 1 , 2 ,3 ] ) // undefined

````

- 이 문제는 어떻게 접근해야할까?


- 팁 : 배열이 정렬되어 있다는 점을 알아야 한다
  - 정렬되어 있지 않으면 효율적인 해결책을 마련하지 않는한 운이 없는 것이다
  - 그러나 이배열은 정렬되어 있기 때문에 합이 0 이 되는 것을 찾으면 된다

---

### AN NATIVE SOLUTION

- 중첩된 루프를 사용한 순진한 해결책

````javascript

    function sumZero( arr ){
        
        for ( let i = 0; i < arr.length; i++ ){
            /** i 나머지를 반복하는 두 번째 루프 */
            for ( let j = i + 1; j < arr.length; j++ ){
                if ( 0 === arr[ i ] + arr[ j ] ){
                    return [ arr[ i ] , arr[ j ] ];
                }
            }
            
        }
    }
    
````

- 시간 복잡도 - **O(n^2)**


- 공간 복잡도 - **O(1)**


- 일치하는 값을 찾을때까지 모든 항목을 비교한다

---

- 방법

- 즉, 배열의 첫번째 값과 마지막값을 더해, 결괏값이 positive( 양수 )이면, 
- 끝쪽 값 포인터를 한칸 앞으로땡겨 비교하고, 결괏값이 negative( 음수 )이면,
- 앞쪽 값 포인터를 한칸 뒤로 땡겨 비교하는 식으로 찾아나간다


- 중첩루프를 사용해 값을 찾는 것보다 훨씬 작업이 줄어들게 된다!!


이것은 **배열이 반드시 정렬되어 있어야한다!!**

---

### REFACTOR

- 리팩터링된 해결책

````javascript

    function sumZero( arr ){
        let left = 0;
        let right = arr.length - 1;
        
        /**  
         * 왼쪽 index 가 오른쪽 index 보다 작을때까지만 작업을 진행해야한다
         * 
         * - 0 과 0 을 더하면 0이 나오기 때문에 같거나 작을때까지가 아닌,
         *   작을때까지만 비교한다!!
         *   
         * - 이렇게 해야 연산을 제대로한다
         */
        while( left < right ){
            let sum = arr[ left ] + arr[ right ];
            /** 합계 값이 0 인 값을 찾으면 해당 값을 반환 */
            if ( 0 === sum ){
                return [ arr[ left ] , arr[ right ] ];
            }
            /** 합계 값이 0 보다 크면 끝쪽 index 를 앞으로 당긴다 */
            else if ( 0 < sum ){
                right--;
            }
            /** 합계 값이 0 보다 작으면 앞쪽 index 를 뒤로 당긴다 */
            else {
                left++;
            }
        }
    }

````

- 시간 복잡도 - **O(n)**


- 공간 복잡도 - **O(1)**


- 이중 배열보다 시간복잡도가 **O(n)** 이라서 훨씬 좋다
- 따라서, 리팩터링된 코드로 볼 수 있다