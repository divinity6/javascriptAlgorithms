## Intermediate Sorting Algorithms

- 더 빠르지만 조금 어렵다


- 직접 작성하기에는 직관적이지 않다


- 이해하는데 더 많은 시간이 걸리지만, 더 빠르다는 보상이 있다


- 이 세가지 알고리즘을 다루는 것은 기초알고리즘에 비해 더욱 더 어렵다
  - ( 코드를 직접 작성해야 한다는 부담을 느끼지 마라 )
  - 그러나 직접 시도하고, 구현하려는 모험자에게는 의사코드를 제공한다


- 그러나 이섹션은 코드의 작동방식을 이해하고, 알고리즘을 설명할 수 있도록 다루는 것이다
  - ( 그 코드를 작성하는 능력을 기르라는 섹션이 아님! )


- Focus : 작동 방식에 집중하고, 각 코드의 행이 수행하는 작업을 다시 설명할 수 있는 능력에 집중


- 까다롭기도하며, 연구자들이 오랫동안 시도하고 시험하며 만든 알고리즘이다

---

### Objectives

- 지금까지 배운 알고리즘의 한계를 이해하는 것
  - ( 버블 , 선택 , 삽입 정렬 )


- merge sort( 합병 정렬 ) 구현


- quick sort( 퀵 정렬 ) 구현


- radix sort( 지수 정렬 ) 구현

---

### WHY LEARN THIS?

- 지금까지 배운 정렬 알고리즘은 큰 규모에는 맞지 않는다


- 20개짜리 항목 배열등과 같이 작은 규모에서 잘 작동한다


- 그러나 10만개의 요소로 작업등에서는 잘 적용되지 않는다
  - 예) 버블 정렬로 10만개의 데이터를 정렬할때는 거의 20초가 걸렸는데
  - 합병정렬로는 1초도 걸리지 않음...( 개사기네이거 ㅋㅋㅋ )

---

### FASTER SORTS

- 앞으로 배울 빠른 알고리즘 집합은 시간 복잡도를 O( n^2 )에서 O( n log n )으로 향상시킬 수 있다


- O( n log n )은 좋은 알고리즘이다
  - log n 과 O( n )만큼 좋지는 않지만 그래도 좋은 알고리즙이다


- 효율성과 단순성은 상충된다


- 효율적인 알고리즘은 더 어렵고, 더 길며 코드가 길지 않아도 더 이상하다


- 그러나 충분히 배울 가치가 있다